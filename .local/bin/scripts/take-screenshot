#!/bin/sh

# screenshot utility frontend

# check for commands
require_cmd() {
    for i in "$@"; do
        command -v "$i" >/dev/null 2>&1 || ! printf "$i: command not found\n" >&2 || exit 127
    done
}

# use $1 as img name
test "$#" -gt 0 && img="$1" && for i in png jpg jpeg jfif avif webp bmp; do
    img="${img%.$i}"
done

# otherwise set img name
test -z "$img" && {
    img="${XDG_PICTURES_DIR:-$HOME/Pictures}/screenshot"
    command -v date >/dev/null 2>&1 && img="${XDG_PICTURES_DIR:-$HOME/Pictures}/$(date +'%Y-%m-%d-%H%M%S_')screenshot"
    test -d "${XDG_PICTURES_DIR:-$HOME/Pictures}" || mkdir -p "${XDG_PICTURES_DIR:-$HOME/Pictures}" || exit $1
}

# numbered suffix for duplicate files
[ -r "$img.png" ] && {
    i=2
    while [ -r "$img~$i.png" ]; do
        i="$((i+1))"
    done
    img="$img~$i.png"
} || {
    img="$img.png"
}

# take a screenshot on wayland
[ -n "$WAYLAND_DISPLAY" ] && {
    # `grim` is required for taking wayland screenshots
    require_cmd grim

    # get a selection using slurp if installed
    command -v slurp >/dev/null 2>&1 && {
        xypos="$(slurp 2>/dev/null)"
        eval "grim${xypos:+ -g \"$xypos\"} \"$img\"" >/dev/null 2>&1
        exit "$?"
    } || {
        grim "$img" >/dev/null 2>&1
        exit "$?"
    }
}

# take a screenshot on x11
[ -n "$DISPLAY" ] && {
    # `scrot` is required for taking x11 screeenshots
    require_cmd scrot

    # take the screenshot
    scrot "$img" -s >/dev/null 2>&1
    exit "$?"
}

# fbgrab is required to take framebuffer screenshots
require_cmd fbgrab

# take a screenshot of a framebuffer console
fbgrab "$img" >/dev/null 2>&1
exit "$?"
